# 30.11 
## Повторение
```c++
int a = 5;
int *b = &a;
int &c = a;
```
Разница между b и с в том, что b - это указатель, с - это ссылка.
Ссылка всегда валидна. Ссылка не может указывать на весь массив.
### Правило трёх -
В классе должны присутствовать: конструктор, деструктор и оператор присваивания или же не должно быть ни одного из них.
### Разница между malloc-free и new-delete
...
### Пространство имён

Нужно для разделения контекста, и при подключении библиотек не было коллизий.

### Перегрузка операторов
```c++
class a{
    a& operator++(); // Инкремент префиксный;
    a operator++(int); // Инкремент постфиксный;
};
```
```c++
class a{
    a operator+(const &a ) const; // const - даёт понять компилятору, что можно применить на const объекте
    a& operator+=(const &a )&; 
};
```
Выражаем '+' через '+=', не наоборот.
```c++
struct base{
    int a;
    void f();
};

struct derrived: public base{
    // Тут у нас есть поле 'a' и метод 'f', но если они будут private, то в они будут не доступны.
    void g(){
        
    }
};
```
### Правила наследования
1) derrived должен быть частным случаем base
2) derrived должен расширять функционал base

**_Protected_** - доступны при наследовании, не доступны для внешнего использования

```c++
int main(){
    derrive d;
    base* b = static_cast<base*>(&d);
}
```

## Виртуальные функции
```c++
struct base{
    int a;
    virtual void f(){} // Тут как такого определения нет
    // void (*f); так f выглядит для компилятора
};

struct derrived: public base{
    void f() override {
        ... // Какое-то определение
    }
};
struct second: base {
    ...
};

int main(){
    derrived d;
    d.f();
    base* b = static_cast<base*>(&d);
    b->f(); // Применится f из derrived, а не из base
    base a;
    a.f(); // Ничего не выполнится, так как в base f не реализована
}
```

```c++
int main(){
    base* b = new derrived();
    b->f(); // Выполнится
    //b = new second(); // Будет ошибка, так как в нём нет определения f
    delete b; // есть опастность, что поля, которые появились в derrived 
    // не будут освобождены, так как для них не будет вызван деструктор
}
```
Эту опасность можно исправить, если сделать деструктор виртуальным.
```c++
struct base{
    int a;
    virtual void f(){} 
    virtual ~base() = default;
};
```

Новое ключевое слово final - запрещает дальнейшее наследование
```c++
struct finel base{
    ...
};
```
```c++
struct t {
    void d();
};
struct k: private t{ // EBCO и t теперь занимает 0 байт;
    ...
}; // private - наследование, при котором пользователи не смогут 
// использовать поля и методы из наследуемого класса
```

```c++
std::vector<int>;
int add(int a, int b){
    return a + b;
}
```
Для каждого типа нужна перегрузка, но логика остаётся одна. Для того, чтобы избежать множественного копирования, используются шаблоны:
```c++
template <typename T>
T add(T a, T b){
    return a + b;
}

int main(){
    add<float>(1.1, 2.2);
    add<int>(1, 2);
    add<double>(1.12345, 2.98653);
    // Теперь у нас одна функция для всех типов
}
```
Шаблон можно использовать для класса. Так например выглядит реализация vector:
```c++
template <class T>
class vector final{
    T* data;
    size_t size, campasity;
    public:
    ...
};
```

## Умные указатели
```c++
    int* a = new int(s);
    delete a;
```
Но есть проблема, так как из программы может быть много выходов, и везде надо удалить указатель

Решение:
```c++
template<typename T>
class unique_ptr{
    T* ptr;
    ...
    ~unique_ptr(){
        delete ptr;
    }
};

int main(){
    unique_ptr a(new int(s));
}
```

Но у нас не всегда может быть указатель реализован динамической памятью. Например, открытый файл.
Доработаный вариант:
```c++
template<typename T, typename del>
class unique_ptr: private del{
    T* ptr;
    ...
    ~unique_ptr(){
        -d(ptr);
    }
};

struct file_del{
    void operator()(FILE* f){
        if (f) fclose(f);
    }
};

int main(){
    FILE *f;
    unique_ptr<FILE, file_del> a(f, file_del());
}
```

## Бонусная техника
"constexpr" - запускает функцию на этапе компиляции, если аргументы доступны на этапе компиляции.
```c++
constexpr std::vector<int> calc_primes(size_t count);

int main(){
    size_t s;
    std::cin >> s; // s - нельзя использовать на этапе компиляции 
    calc_primes(s); 
    constexpr vector v = calc_primes(5); // 5 - можно узнать на этапе компиляции, поэтому и функция будет посчитана на этапе компиляции.
}
```
## Рубрика вопрос-ответ:
1) Про шаблоны не будет на зачёте, вопросы заканчиваются на наследовании
2) Конвертация числа из строки - это умение в ручную перевести строку в число
3) Если в базовом классе есть чисто виртуальные функции, но они не определены в классах наследниках, то при попытке создать объекта класса-наследника будет ошибка.
4) Быстрое возведение в степень - описание словами алгоритма, можно использовать код, но желательно без рекурсии
5) Теория можно без кода, задачи основном код
6) Два типа задач:
   1) Реализация, какой-нибудь функции из базовых(Пример: перевод числа в строку и строки в число)
   2) Реализация какого-нибудь алгоритма.
7) На все задачи проверяем malloc
8) Константин Владимиров (MIPT c++) полезные видео по с++