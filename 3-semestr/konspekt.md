# Конспект за 12.10
## Работа, и вопросы по malloc
1. malloc(0) - неопределённое поведение

2. realloc(size / 2) - попытка уменьшить массив с помощью реаллок приводит неопределённое поведение

3. Возвращать указатель на локальный массив нельзя!

```c 
int func(T arg, ...)
```

**Для функции с приёмом неизвестного числа аргументов, подключаем библиотеку stdarg.h (возможно надо подключить stdlib.h)  
Макросы**:
 * **va_list** - нетипизированный указатель на память  
 * va_start  
 * vs_arg 
 * vs_end 

```c
#define va_start(ap, parm) (ap) = (char*)(&(parm + 1))
// parm - последний явно переданный аргумент
```
## Макросы - Замена в тексте кода
```c
#define sqr(a, b) (a) * (b);
// Обязательно ставить скобки, иначе можно получить непредвиденное поведение
```

- **va_arg** принципы работы
```c
#define va_arg(ap, type) ((type*)((char*)(ap) += sizeof(type)))[-1]
```
1. Считывание очередного аргумента типа type
2. ```[-1]``` - берём элемент до той ячейки памяти предыдущего элемента
3. Пример использования
```c
int x;
x = va_arg(ap, int);
// 0 может быть в конце, а может и не быть, поэтому надеяться, что оно само ограничится не приходится
```

Пример 1 - указатель на функцию
```c
double Foo(double x, int y) {
...
return x; // ?
}
int main(void) {
    double(*pf)(double, int);
    double y;
    pf = Foo;
    y = pf(0.5, 4); // разыменование указателя и передачи аргументов в функцию
    double(*pArr[10])(double, int);
    y = pArr[2](1.5, 10);
}
```
<u>Задача 1:</u>\
Пользователь вводит неизвестное количество строк неизвестной длины, но меньше чем "_BUFSIZE_". 
Конец ввода пользователь обозначает словом "_STOP_". Вывести все введённые пользователем строки.
```c
int main(void) {
    char** pArr = (char **) malloc(2 * sizeof(char *) );
    if (pArr == NULL) return 1;
    char buf[BUFSIZ];
    int i = 0, j, count = 2;
    // Считывание строк
    while (1){
        printf("Input string:\n");
        gets(buf);
        if (!strcmp(buf, "STOP")) break;

        if (i == count){
            count *= 2;
            char** ptr = (char **) realloc(pArr, count * sizeof(char*)); // А вдруг релок всё сломает, нужна проверка
            if (ptr == NULL){
                printf("Alloc Error!!!\n");
                for (j = 0; j < i; j++){
                    free(pArr[j]);
                }
                free(pArr);
                return -1;
            }
            pArr = ptr;
        }
        i++;
        pArr[i - 1] = (char *) malloc((strlen(buf) + 1) * sizeof(char)); // Тут тоже проверка
        if (pArr[i - 1] == NULL) {
            printf("Alloc Error!!!\n");
            for (j = 0; j < i - 1; j++){
                free(pArr[j]);
            }
            free(pArr);
            return -1;
        }
        strcpy(pArr[i - 1], buf);
    }
    // Печать строк
    for (j = 0; j < i; ++j){
        printf("%s\n", pArr[j]);
    }
    // Освобождение памяти
    for (j = 0; j < i; j++){
        free(pArr[j]);
    }
    free(pArr);
    return 0;
}
```
**Структура в С** \
Тип данных с разнотипными переменными.
```c
struct MySrt{ // Объявление типов данных, переменных таких нет.
    int x, y;
    char ch;
    double d;
    char s[256];
    int* pint;
};
struct My{
int x;
char ch;
}; // Примерный размер sizeof(My)

// Объявление переменной нашего типа
struct MySrt st;
st.x = 10;
st.y = st.x + 2;
strcpy(st.s, "Hello!");

struct MySrt* pStr = NULL;
pStr = &st;
(*pStr).y = 100;
pStr->y = 500; //Если указатель используеме ->
```

**Объединение в С**
```c
union MyUn{ // объявления объединения - все поля размещаются вместе
    float f;
    int x;
    char s[4];
};

int i = 0;
union MyUn u;
u.x = 233;
u.f = -1.5;
while (i < 4){
    printf("%x", u.s[i++]);
}
```
### Самоссылочные структуры
В структурах разрешено иметь тип данных указатель на эту же структуру. Тип данных самой структуры иметь не может.
```c
struct Node{
    int data;
    struct Node* pNode;
};
```
**Односвязные списком(однонаправленным списком)** называется структура данных, которая является набором элементов следующего типа:
- В каждом элементе есть поле "данные"
- указатель на следующий элемент
#### Типичные операции:
1. Доступ к элементу (посещение)
2. Добавление
3. Удаление
